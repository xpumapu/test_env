#!/usr/bin/tclsh

package require Tclx

source lib/lib-daem.tcl
source lib/lib-cli.tcl
source lib/lib-ls.tcl

set log_file "/tmp/daem.log"
set pidfile_path "$pidfile_dir/[file tail $argv0].pid"



;# gets curent date and time
proc get_time {} {
	return [clock format [clock seconds]]
}

;# log message to file
;# dfd - debug file descriptor, open for writing
;# msg - text message
proc log {dfd msg} {
	puts $dfd "[get_time]: $msg"
}

proc shutdown {} {
	;#whatever cleanup you need to do
	set fd [open shut.log a+]
	fconfigure $fd -buffering none
	puts $fd "[get_time]: Main process shutdown"
	close $fd
	exit
}

proc handle_cmd_get {args ns dfd} {
	set firstarg [lindex $args 0]

	switch $firstarg {
		"ifaces" {
			log $dfd "get ifaces"
			set l_ifaces [ls_get_ifaces]
			puts $ns "ifaces: $l_ifaces"
		}
		"quit" {
			log $dfd "quiting..."
		}
		"get" {
			log $dfd "get: $args"
		}
		"pid" {
			log $dfd "pid:[pid]"
		}
		"test" {
			log $dfd "test: $args"
		}
	}
}

proc handle_cmd {cmd args ns dfd} {

	switch $cmd {
		"none" {
			log $dfd "none"
		}
		"get" {
			log $dfd "get: $args"
			handle_cmd_get $args $ns $dfd
		}
		"run" {
			log $dfd "run: $args"
		}
		"test" {
			log $dfd "test: $args"
		}
	}
}

proc read_data {ns fd} {
	log $fd "[lindex [info level 0] 0]"

	set status [catch {gets $ns line} result]

	if {$status != 0} {
		log $fd "error reading $ns: $result, closing sock..."
		close $ns
	} elseif {$result >= 0} {
		log $fd "received: >$line<"
		set parcmd [parse_line $line]
		handle_cmd [dict get $parcmd cmd] [dict get $parcmd args] $ns $fd
	} elseif {[eof $ns] == 1} {
		log $fd "sock $ns: eof, closing sock..."
		close $ns
	} else {
		log $fd "impossible"
	}
}

;# server function processing each new connected client
proc server_process {fd ns addr port} {
	fconfigure $ns -buffering line -blocking 0
	log $fd "server process: chan $ns addr $addr port $port"

	;# setup read/write callbacks
	fileevent $ns readable [list read_data $ns $fd]
}

;# register server function and wait forever
proc server_register {fd} {
	set ns [socket -server [list server_process $fd] 7707]
	log $fd "server registered sock $ns, waiting for clients..."
	vwait forever
}

proc daemon_process {fd} {
	log $fd "daemon pid [pid]"

	server_register $fd
}

proc mysigterm {} {
	set fd [open term.log a+]
	fconfigure $fd -buffering none
	puts $fd "[get_time]: sigterm"
	close $fd
}

proc start_daemon {fd} {
	close stdin
	close stdout
	close stderr
	set pro [fork]
	if {$pro} {
		exit 0
	}
	id process group set

	set pro [fork]
	if {$pro} {
		exit -1
	}
	set sd [open /dev/null r]
	set sd [open /dev/null w]
	set sd [open /dev/null w]
	cd /
	umask 022
	return [id process]
}


;#
;# start here
;#

;# check if pidfile exists
if {[file exists $pidfile_path]} {
	puts "error: $$pidfile_path already exists"
	exit -1
}

;# delete log file
file delete $log_file

;# open and configure file for new logs
set fd [open $log_file a+]
fconfigure $fd -buffering none
log  $fd "startup [pid]"

;# start daemon process
set daem_id [start_daemon $fd]
log $fd "start daemon pid $daem_id"

;# create pidfile
set pid_fd [open $pidfile_path w]
puts $pid_fd "$daem_id"
close $pid_fd


;# configure signals
signal ignore  SIGHUP
signal unblock {QUIT TERM}
signal trap    QUIT shutdown
signal trap TERM mysigterm

;# start daemon processing
daemon_process $fd

